//十个linux指令
/*
cd ~ :返回到根目录
ls -l L* : 列出当前目录下所有L打头的文件,最新的在最后面
zip : 压缩文件 压缩后会另外产生".zip"扩展名的压缩文件
clear : 清除屏幕
date : 显示或设定系统的日期与实践
who : 显示系统使用者,包含用户ID,使用的终端机,从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。
who -h : 不显示标题列
who -u : 不显示使用者的动作/工作
who -s : 使用简单格式显示
who -f : 不显示使用者上线位置
who -V : 显示程序版本
df : 显示目前在Linux系统上的文件系统的磁盘使用情况统计
dirs : 显示目录记录
dirs -l : 显示目录完整的记录
du : 显示目录或文件的大小
du -a : 显示目录中个别文件的大小
cp -r zy/ newzy: 将zy下的文件复制到新目录下
*/

//10个git指令
/*
git add : 添加至暂存区
git add–interactive : 交互式添加
git apply : 应用补丁
git am : 应用邮件格式补丁
git annotate : 同义词，等同于 git blame
git archive : 文件归档打包
git bisect : 二分查找
git blame : 文件逐行追溯
git branch : 分支管理
git cat-file : 版本库对象研究工具
git checkout : 检出到工作区、切换或创建分支
git cherry-pick : 提交拣选
git citool : 图形化提交，相当于 git gui 命令
git clean : 清除工作区未跟踪文件
git clone : 克隆版本库
git commit : 提交
git config : 查询和修改配置
git describe : 通过里程碑直观地显示提交ID
git diff : 差异比较
git difftool : 调用图形化差异比较工具

*/


//let
/*
1,let 用来声明变量,作用与var类似,但let声明的变量仅限所在的代码块内有作用
2,在for循环中,计数器i只会在循环体内有作用,循环体外失效,引用会报错.每次循环,i都是一个新的变量,在js引擎内部会记录循环式上一轮循环的值
3,let声明的变量不存在变量提升,即不可以在变量声明前使用,必须声明后才能使用
4,存在暂时性死区,let声明的变量会绑定在这个区域,不受外部影响,在let声明前被锁死,直接使用会报错
5,不允许在相同作用域内重复声明一个变量
*/

//const命令
/*
1,声明一个只读的常量,一旦声明,常量的值不能发生改变
2,一旦声明就必须立刻初始化,不能留到以后赋值.只声明不赋值会报错
3,作用域与let相同,也是不提升,也存在暂时性死区,不可重复声明一个变量
4,本质并不是常量的值不能改变,是指变量指向的内存地址不得改变.对于简单数据,值是保存在变量指向的内存地址.但对于符合类型数据,变量指向的内存地址是一个指针.也就是说const保证的是指针的固定.而它指向的数据结构就完全不能控制了
*/

//变量解构
/*
1, ES6 允许按照一定模式,从数组和对象中提取值,对变量进行赋值,这种被称为解构
2,ES6允许这么写:  let [a, b, c] = [1, 2, 3];  按照对应位置对变量进行赋值
3,本质属于模式匹配,只要等号两边模式相同就会一一匹配,但如果不相同,不能一一匹配,那个没匹配到的会等于undefined,属于解构不成功
4,如果右边是不可遍历的解构,会报错
5,解构赋值允许指定默认值
6,解构不仅可以用于数组,也可以用于对象,与数组的重要不同在于数组是按顺序排列,变量的取值是由位置决定的,而对象是通过与属性名相同取值
7,与数组一样,解构也可用于嵌套结构对象
*/

//箭头函数
/*
1,允许用"箭头"定义函数
var f = v => v;
上面的箭头函数等同于：

var f = function(v) {
  return v;s
};
*/
